⭐
1. 우선순위 큐(heapq) 
2. key = lambda x: x[] --> 정렬 기준 정해주기 (-x[] 면 반대차순으로 정렬)
3. list.count(x) --> 안에 x가 몇개 있는지
4. list.index(x) --> x가 list안에서 몇번째인지
5. 문자열 합치기 "".join(x) --> x문자열을 "" 공백없이 합쳐준다
6. list.pop(x) --> x번째 인덱스를 리스트에서 삭제하고 돌려주는 역할
        pop()  --> 맨 마지막 요소를 리스트에서 삭제하고 돌려주는 역할
7. words = words.replace("x", "a") --> words 리스트 안에있는 "문자열 x"를 a로 바꿔준다. (백준 문제 2941, 2021 카카오 코테)

8. sys.setrecursionlimit(100000) 재귀 함수를 쓴다면 기본 깊이가 1000이라 너무 작아서 이 함수로
재귀를 풀어줘야 한다. 재귀함수 할때는 무조건 사용하기

9. 반복문(O(N))보다 재귀함수(O(2^N))가 시간 복잡도가 더 크다. 이중 for 문(O(n^2))
-> 반복은 for, while 같은 거, 재귀는 return하는 함수

10. 재귀 함수 이해하기 --> (재귀함수)

11. deque append 할 때 좌표처럼 nx, ny 면 q.append((nx, ny)) 괄호 두번, nx 하나면 q.append(nx)

<순열, 조합, 중복조합 활용>
12. permutations(nPm), combinations(nCm), combinations_with_replacement(중복조합 nHm) 알아두기 
-> (2019 카카오 인턴쉽 불량 사용자, 2020 카카오 인턴쉽 수식 최대화, 2021 카카오 블라인드 
메뉴 리뉴얼, 2022 카카오 블라인드 양궁대회)

<딕셔너리, defaultdict, 집합 활용>
13. 딕셔너리에서 키값과 value값 모두 얻으려면 .items(), dict의 활용 
딕셔너리 정렬(key 값, value 값), 딕셔너리 키 값 출력, 딕셔너리.get() 사용하는 법 
[book_store.get(k, 0) for k in buy_list] for 문 한번에 쓰기. defaultdict의 활용, 
set은 add , += 이나 .append 쓰고 싶으면 defaultdict(int), defaultdict(list) 활용하기
--> (2018 카카오 블라인드 프렌즈4블록, 2019 카카오 블라인드 실패율, 2021 카카오 블라인드 숫자
문자열과 영단어, 2021 카카오 웹 백엔드 다단계 칫솔, 2022 카카오 블라인드 신고 결과 받기)

<진수 변환, 소수 찾기>
14. 진수 변환의 모든 것, 진수 변환의 혁명, 진수 변환 알고리즘 
word = str(n%k) + word 이 방식 알아두기(2진수에서 가능), 소수 찾는 방법 
(2018 카카오 블라인드 n진수 게임, 2022 카카오 블라인드 k진수에서 소수 찾기)

<문자열 문제, 누적합 문제>
15. 문자열 문제, not .isdigit()의 활용, 문자열 이용하는 새로운 방식, 문자열 슬라이싱
알고리즘 생각하기 어렵다
 --> (2018 카카오 블라인드 뉴스, 파일명 정렬, 좋은 문제 -> 분해합 , 2020 카카오 
블라인드 문자열 압축, 2022 카카오 블라인드 k진수에서 소수 찾기, 2018 카카오 블라인드 비밀지도,
11659 구간 합 구하기 4)

<BFS, 좌표문제>
 --> (2020 카카오 블라인드 경주로 건설하기, summer/winter 2018 방문 길이)

16. zip 함수 --> (2021 카카오 웹 백엔드 다단계 칫솔)

17. 조건을 만족하는 인원수의 최댓값, 범위가 매우 클 때(1,000,000은 생각보다 적은 탐색 범위)
-> 이분 탐색 (1920, 2805, 2019 카카오 인턴쉽 징검다리 건너기)

18. 연결 리스트 (2021 카카오 표 편집)

19. 비트 연산자 계산, 함수 두번 사용, zfill, 문자열 추가 방식 (2018 카카오 블라인드 비밀지도)
-> arr1_bin[i][p] 이 표현은 arr1_bin[i]가 12345였을 경우 그중 p번째 인덱스의 값, ex) p = 1이면, 2

20. 대소문자 cache.upper(), cache.lower(), LRU (2018 카카오 블라인드 캐시)

21. 이분탐색 10816, 딕셔너리 3003 -> 좋은 딕셔너리 예제

22. counter 함수, 문자열 문제 풀기 좋은 알고리즘, isalpha() (2018 카카오 블라인드 뉴스)
-> 알파벳인지 확인하기(isalpha), 숫자인지 확인하기(isdigit), 알파벳 또는 숫자인지 확인하기(isalnum) 

23. if, else문 한줄로 쓰기, 스택방식으로 문제 풀기 (2018 카카오 블라인드 다트게임)

24. 전체적으로 탐색을 해야할 때 (2018 카카오 블라인드 다트게임, 2018 카카오 블라인드 압축)

25. 좌표 문제, 좌표 삭제, 집합의 이용(set, add) (2018 카카오 블라인드 프렌즈4블록) 

26. 문제를 풀 때는 한번에 다 해결하려는 것이 아니라, 풀어야 하는 케이스의 경우가 많으면 그 하나를 
정답이 되도록 푸는 식으로 알고리즘을 짜야 한다. --> (2018 카카오 블라인드 방금그곡)

27. heapq 기본은 최소힙 이기 때문에 부모 노드가 자식 노드보다 무조건 작다.
--> (그리디 1715, 2019 카카오 블라인드 무지의 먹방라이브)

28. 리스트에 추가하는 append말고 다른 방식, combination, "".join을 한줄로 쓰는 방식
dictionary와 join과 리스트의 추가적인 응용방식과 알고리즘 응용방식 다 적어둠.
--> (2021 카카오 블라인드 메뉴 리뉴얼)

29. 행렬의 회전 알고리즘 --> (2021 카카오 웹 백엔드 행렬 테두리 회전)

30. dict와 zip의 활용, 알고리즘 짜는 방법 신기하다, break 쓰는 방법, math라이브러리 사용
--> (2021 카카오 웹 백엔드 다단계 칫솔)

<if, else 한줄로 쓰기>
31. if, else 한줄로 쓰기, 효율성 체크, 누적합
 --> (2022 카카오 블라인드 파괴되지 않은 건물, 2022 카카오 인턴쉽 성격 유형 검사)

32. deque 문제 --> (2022 카카오 인턴쉽 두 큐 합 같게 만들기)

33. 월간 코드 챌린지 -> 삼각 달팽이. 

<게임 문제>
징검다리 건너기(이분 탐색), 보석 쇼핑(투포인터), 경주로 건설하기(bfs)

2019 카카오 인턴쉽 크레인 인형 뽑기 LV1 (break 반복문 탈출이라는것 생각하기) 



<백준 문제>

2581과 1929, 4948의 차이 (1929 시간 초과 에라토스테네스의 체)

2750 파이썬은 정렬에 sort쓰지만, 다른 언어의 경우 버블 정렬, 삽입 정렬
2751 수의 범위가 커지는 경우 병합정렬, 정렬 라이브러리
10989 시간 초과 생각하기

10757 시간초과를 조금이나 줄일 수 있는 방법

2108 counter 함수 이해하기

1157 for문에서 range안쓰는 예시 --> 1427이랑 같이 보기 , index와 count활용

**11650, 11651 함수 정렬에 관한 문제 key = lambda의 사용법 알아두기
**10814, **1931(그리디) key = lambda 응용

1181 sys.stdin.readline().strip() 쓰는 방법 알아두기 
-> # readline의 경우 맨 뒤에 '\n'까지 입력받으므로 제거해줘야 함

*18870 딕셔너리에 대해서 이해하기 

10870, 10872 재귀 함수에 대해 이해하기

10828 스택 문제


<그리디 알고리즘>

2839, 11047, 5585 나눴을 때 몫과 나머지가 알고리즘에서는 잘 쓰인다.

1026 pop의 활용

1541 알고리즘 이해하기, split의 중요성

10162 알고리즘 공부하기

13305 알고리즘 이해라기 좋은예제

***10610 list 형태와, (in, not in) 연산자 형태와 "".join()에 관한 내용. , sys 모듈 문제점

***1715 heapq 이해하기

16953 개어려움 deque 이해못함

4796 포맷팅 관련

1931, 1946 알고리즘

1049 다른 이름으로 리스트에 정렬해주려면 cost.sort(~)가 아니라 x = sorted(cost, ~)


<그래프 탐색>

2178 최단경로는 bfs, 이중 for문 n*m 인지 m*n인지 잘 보기

2606, 1260 dfs, bfs 모든것


<동적 프로그래밍 dp>

9095 진짜 천잰가..? 점화식 알고리즘(피보나치 수열) 기본

11726 시간복잡도 때문에 반복문 써야함, sys.setrecursionlimit(100000)


<카카오 코테> -> 흰색은 함수 이름 ex) list, abs 이런거 초록색은 변수 이름 내 맘대로 짓던것들 ex) tmp, n 이런거

1541과 튜플 split의 중요성

수식 최대화 -> 문자열로 표현된 파이썬 식을 인수로 받아 결과값은 내주는 파이썬 내장함수 eval() 이
               문자열로 된 수식을 계산할때 유용하게 사용될 수 있다.
               eval("*".join(tmp)) 이렇게 하면 join으로 str형이 였던 결과가 eval로 계산하면서
               int 형으로 바뀐다. 그리고 permutations을 사용한다.

경주로 건설 -> 새로운 bfs형식, continue(하위 코딩만 무시하고 반복문은 계속한다.)

불량 사용자 -> permutations, combinations의 구분

***징검다리 건너기 -> 중요한 알고리즘 + 이분 탐색

-> 얕은 복사 = (=), (:), .copy(), 깊은 복사 = import copy  copy.deepcopy()

arr1 = [1,2,3]이고                   ->                  arr1 = [1,2,3,4]    
arr2 = arr1               (arr1.appned(4)을 해보면)      arr2 = [1,2,3,4]  

immutable 한 객체들 int, float 등은 얕은 복사를 하던 깊은 복사를 하던 사실 상관이 없습니다.
왜냐하면 해당 객체들은 값이 변경되면 '무조건' 참조가 변경되기 때문에

num1 = 3                        ->                      num1 = 4
num2 = num1         (이때 num1 = 4를 하게 되면,)         num2 = 3

결론적으로 파이썬에서는 "얕은 복사"냐 "깊은 복사"냐에 대해서 구분하고 학습해야 하는 객체는
int, float와 같은 immutable(변하지 않는) 한 객체들이 아니라 (X)
list, set, dictionary와 같은 mutable 한 객체들입니다. (O)

** 숫자 문자열과 영단어 
-> Key, Value 쌍 얻기(items)
>>> a.items()
dict_items([('name', 'pey'), ('phone', '010-9999-1234'), ('birth', '1118')])
items 함수는 Key와 Value의 쌍을 튜플로 묶은 값을 dict_items 객체로 돌려준다.

*** 표 편집 개어려움 linked_list 기본 틀만 알아두기

***** [1차] 비밀지도 
-> append 방식 알아두기, zfill 사용, 함수 연속 두번사용(tmp.replace("1", "#").replace("0", " ")) 
   비트연산자를 이용한 계산

방금그곡이랑 보석쇼핑에서 if elif와 if if 쓰는 것의 차이 알아두기, 보석쇼핑 answer = [] 일 때 
answer.append([a,b]) 이렇게 넣으면 answer = [[a,b], []] 로 이중 리스트가 되니깐 answer = [a, b] 해주면
리스트에 값이 들어간 꼴이 된다.
