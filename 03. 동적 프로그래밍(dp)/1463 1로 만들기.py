import sys
input = sys.stdin.readline

n = int(input())

d = [0] * (n+1)

for i in range(2, n+1):
    d[i] = d[i-1] + 1

    if i % 2 == 0:
        d[i] = min(d[i], d[i//2] + 1)
    if i % 3 == 0:
        d[i] = min(d[i], d[i//3] + 1)

print(d[n])

"""
이 문제는, 전의 결과를 다음 결과에 이용하게 되는. 점화식을 활용한 DP 문제이다.
X = 10인 경우, 10 -> 9 -> 3 -> 1  과정을 거쳐 1이 되게 되는데
9의 경우에는 또, 9 -> 3 -> 1의 과정을 거치며, 3의 경우에는 3 -> 1의 과정을 거친다.

즉, 10을 구할 때는 9의 결과를, 9를 구할 때는 3의 결과를 이용한다.
앞에서 구한 결과값을 저장하였다가 후에 사용하는 것이다.

x에 수를 입력받습니다. dp리스트인 d를 0이 (x+1) 개 있는 리스트로 초기화합니다. d는 인덱스의 숫자가
1이 되는데 필요한 연산의 최솟값을 갖습니다. 즉, d[1]은 0으로 1이 1로 되는데 필요한 연산은 0회이기 
때문입니다. d[2]는 2가 1이 되는데 필요한 최소 연산 횟수인 1이 될 것입니다. 

for i in range(2, x+1): 을 통해 2부터 x까지 i로 반복합니다.
d[i]=d[i-1]+1 : d[i]는 숫자 i가 1이 되는데 걸리는 최소한의 연산 횟수를 저장해야 합니다. i에서 1을 
빼면 i-1이 되므로, d[i-1]+1을 함으로써, d[i-1] (i-1이 1이 되는데 필요한 최소한의 연산) + 
1 (i에서 1을 빼서 i-1이 되는데 필요한 연산 횟수 1회)로 초기화합니다. 예를 들어, d[3] = d[2] +1 
이라고하면, 3에서 1을 빼는 1회 연산을 통해 2가 되므로, d[2] + 1은 3에서 1을 빼서 2가 되고, 
d[2] (2에서 1이 되는데 필요한 최소 연산 횟수)를 더해준 것입니다. 

if i%2==0:    d[i]=min(d[i],d[i//2]+1) : i가 2로 나누어 떨어질 때, 
d[i]와 d[i//2]+1중 최솟값을 d[i]에 저장합니다. d[i]는 위에서 초기화한 d[i-1]+1값이 들어있습니다. 
이것과 d[i//2]+1을 비교해 최솟값을 d[i]에 넣습니다. d[i//2]의 의미는 i가 2로 나누어 떨어진다고 
조건문에서 확인했으니, i를 2로 나눈 값이 1이 되는데 걸리는 최소한의 연산 횟수를 의미합니다. 즉, 
d[i//2]+1은 i를 2로 나눈 값이 1이 되는데 걸리는 최소 연산 횟수 + i를 2로나누는 연산횟수 1회입니다.

if i%3==0:    d[i]=min(d[i],d[i//3]+1) : i가 3으로 나누어 떨어질 때, d[i]와 d[i//3]+1 중 
최솟값을 d[i]에 저장합니다. 현재 d[i]는 d[i-1]+1과 i가 2로 나누어 떨어지는 경우, d[i//2]+1중 
최솟값이 들어있습니다. 여기에 i가 3으로 나누어 떨어지는 경우 d[i//3]+1과도 값을 비교해 최솟값을 
d[i]에 넣습니다.
"""


# BFS
from collections import deque

x=int(input())
Q=deque([x])
visited=[0]*(x+1)

while Q:
    c=Q.popleft()
    if c==1:
        break
    if c%3==0 and visited[c//3]==0:
        Q.append(c//3)
        visited[c//3]=visited[c]+1
    if c%2==0 and visited[c//2]==0:
        Q.append(c//2)
        visited[c//2]=visited[c]+1
    if visited[c-1]==0:
        Q.append(c-1)
        visited[c-1]=visited[c]+1

print(visited[1])

"""
예를 들어, x가 10일 때, 2로 나누어 떨어지니까 visited[5]에는 1이 들어갑니다. 10에서 1을 빼면 
visited[9]에도 1이 들어갑니다. 그러고 Q에는 각각 5와 9가 들어갑니다. 5일 때는 1을 빼는 연산을 
한 번 더 하기 때문에, visited[4]에는 2가 들어갑니다. 9는 3으로 나누어 떨어지니까 visited[3]에도 
2가 들어갑니다. 9에서 1뺀 visited[8]에도 2가 들어갑니다. 그러면 현재 Q에는 4,3,8이 들어있습니다.
이중 3에서 3으로 나누어 떨어지니까 바로 1이 되며, visited[1]에는 3이 들어갑니다. 
그래서 최종적으로 visited[1]을 출력하면 정답입니다
"""